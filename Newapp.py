import streamlit as st
import pandas as pd
import numpy as np
from itertools import combinations
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime, timedelta
import json
from io import StringIO

# Configuration de la page
st.set_page_config(
    page_title="FC25 Ultimate Team Builder Pro",
    page_icon="‚öΩ",
    layout="wide"
)

# CSS personnalis√© pour un design pro
st.markdown("""
<style>
.main-header {
    font-size: 3rem;
    background: linear-gradient(90deg, #FF6B35, #F7931E);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    text-align: center;
    margin-bottom: 1rem;
}
.mode-card {
    padding: 1rem;
    border-radius: 10px;
    border: 2px solid #ddd;
    margin: 0.5rem;
    text-align: center;
    transition: all 0.3s;
}
.mode-card:hover {
    border-color: #FF6B35;
    box-shadow: 0 4px 15px rgba(255, 107, 53, 0.3);
}
.player-card {
    text-align: center;
    padding: 10px;
    border-radius: 15px;
    margin: 5px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
}
.metric-card {
    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    padding: 1rem;
    border-radius: 10px;
    color: white;
    text-align: center;
}
</style>
""", unsafe_allow_html=True)

st.markdown('<h1 class="main-header">‚öΩ FC25 ULTIMATE TEAM BUILDER PRO</h1>', unsafe_allow_html=True)
st.markdown("**üî• L'outil le plus avanc√© pour construire votre √©quipe de r√™ve !**")

# D√©finition des formations tactiques avec bonus
FORMATIONS = {
    "4-3-3 (Attaque)": {
        "positions": {"GK": 1, "CB": 2, "LB": 1, "RB": 1, "CDM": 1, "CM": 2, "LW": 1, "RW": 1, "ST": 1},
        "bonus": {"attack": 15, "defense": 0, "creativity": 10}
    },
    "4-4-2 (√âquilibr√©)": {
        "positions": {"GK": 1, "CB": 2, "LB": 1, "RB": 1, "LM": 1, "CM": 2, "RM": 1, "ST": 2},
        "bonus": {"attack": 5, "defense": 5, "creativity": 5}
    },
    "3-5-2 (Possession)": {
        "positions": {"GK": 1, "CB": 3, "LWB": 1, "RWB": 1, "CDM": 1, "CM": 2, "ST": 2},
        "bonus": {"attack": 0, "defense": 10, "creativity": 15}
    },
    "4-2-3-1 (Cr√©atif)": {
        "positions": {"GK": 1, "CB": 2, "LB": 1, "RB": 1, "CDM": 2, "CAM": 3, "ST": 1},
        "bonus": {"attack": 10, "defense": 0, "creativity": 20}
    },
    "5-3-2 (D√©fense)": {
        "positions": {"GK": 1, "CB": 3, "LWB": 1, "RWB": 1, "CM": 3, "ST": 2},
        "bonus": {"attack": -5, "defense": 20, "creativity": 0}
    },
    "3-4-3 (Intense)": {
        "positions": {"GK": 1, "CB": 3, "LM": 1, "RM": 1, "CM": 2, "LW": 1, "RW": 1, "ST": 1},
        "bonus": {"attack": 20, "defense": -5, "creativity": 5}
    }
}

# Modes de jeu avanc√©s
GAME_MODES = {
    "üöÄ Ultimate Team": {
        "description": "Mode ultime avec chimie et synergies",
        "budget_multiplier": 1.0,
        "focus": "chimie",
        "constraints": {"max_same_nationality": 4, "min_different_leagues": 3}
    },
    "üíé Chasse aux P√©pites": {
        "description": "Jeunes talents √† fort potentiel",
        "budget_multiplier": 0.7,
        "focus": "potential",
        "constraints": {"max_age": 23, "min_potential_gap": 5}
    },
    "üëë Galactiques": {
        "description": "Les meilleurs joueurs absolus",
        "budget_multiplier": 3.0,
        "focus": "overall_rating",
        "constraints": {"min_overall": 85}
    },
    "üí∞ Mercato R√©aliste": {
        "description": "Budget incluant salaires 3 ans",
        "budget_multiplier": 1.5,
        "focus": "value_for_money",
        "constraints": {"include_wages": True}
    },
    "‚öñÔ∏è Qualit√©/Prix": {
        "description": "Meilleur rapport performance/co√ªt",
        "budget_multiplier": 0.8,
        "focus": "efficiency",
        "constraints": {"max_price_per_overall": 15}
    }
}

# Mapping des positions compatibles (√©tendu)
POSITION_COMPATIBILITY = {
    "GK": ["GK"],
    "CB": ["CB", "SW", "CDM"],
    "LB": ["LB", "LWB", "LM", "CB"],
    "RB": ["RB", "RWB", "RM", "CB"],
    "LWB": ["LWB", "LB", "LM", "LW"],
    "RWB": ["RWB", "RB", "RM", "RW"],
    "CDM": ["CDM", "CM", "CB", "DM"],
    "CM": ["CM", "CDM", "CAM", "LM", "RM"],
    "LM": ["LM", "LW", "LB", "LWB", "CM"],
    "RM": ["RM", "RW", "RB", "RWB", "CM"],
    "CAM": ["CAM", "CM", "CF", "LW", "RW"],
    "LW": ["LW", "LM", "LF", "ST", "CAM"],
    "RW": ["RW", "RM", "RF", "ST", "CAM"],
    "ST": ["ST", "CF", "LF", "RF", "CAM"]
}

@st.cache_data
def load_data(uploaded_file):
    """Charge et nettoie les donn√©es du CSV avec traitement avanc√©"""
    try:
        df = pd.read_csv(uploaded_file)
        
        # Nettoyage des colonnes de prix
        if 'value' in df.columns:
            df['value_clean'] = df['value'].astype(str).str.replace('‚Ç¨', '').str.replace(',', '')
            df['value_numeric'] = pd.to_numeric(
                df['value_clean'].str.replace('M', '').str.replace('K', ''), 
                errors='coerce'
            )
            # Conversion en millions
            mask_k = df['value_clean'].str.contains('K', na=False)
            df.loc[mask_k, 'value_numeric'] /= 1000
        
        if 'wage' in df.columns:
            df['wage_clean'] = df['wage'].astype(str).str.replace('‚Ç¨', '').str.replace(',', '')
            df['wage_numeric'] = pd.to_numeric(
                df['wage_clean'].str.replace('K', '').str.replace('M', ''), 
                errors='coerce'
            )
            mask_k = df['wage_clean'].str.contains('K', na=False)
            df.loc[mask_k, 'wage_numeric'] /= 1000
        
        # Calculs avanc√©s
        df['age'] = 2025 - pd.to_datetime(df['dob'], errors='coerce').dt.year
        df['potential_gap'] = df['potential'] - df['overall_rating']
        df['value_per_overall'] = df['value_numeric'] / df['overall_rating']
        df['efficiency_score'] = df['overall_rating'] / np.log1p(df['value_numeric'])
        
        # ID unique si pas pr√©sent
        if 'player_id' not in df.columns:
            df['player_id'] = range(len(df))
            
        return df
    except Exception as e:
        st.error(f"‚ùå Erreur lors du chargement: {e}")
        return None

def calculate_team_chemistry(selected_players):
    """Calcule la chimie d'√©quipe bas√©e sur nationalit√©s et clubs"""
    if not selected_players:
        return 0
    
    nationalities = [p['player'].get('nationality', 'Unknown') for p in selected_players]
    clubs = [p['player'].get('club_name', 'Unknown') for p in selected_players]
    
    # Bonus nationalit√©s communes
    nationality_counts = pd.Series(nationalities).value_counts()
    nationality_bonus = sum([count * 2 for count in nationality_counts if count > 1])
    
    # Bonus clubs communs
    club_counts = pd.Series(clubs).value_counts()
    club_bonus = sum([count * 3 for count in club_counts if count > 1])
    
    # Bonus formation
    base_chemistry = 50
    total_chemistry = min(100, base_chemistry + nationality_bonus + club_bonus)
    
    return total_chemistry

def calculate_team_stats(selected_players, formation):
    """Calcule les statistiques avanc√©es de l'√©quipe"""
    if not selected_players:
        return {}
    
    players_data = [p['player'] for p in selected_players]
    
    # Stats de base
    avg_overall = np.mean([p['overall_rating'] for p in players_data])
    avg_potential = np.mean([p.get('potential', p['overall_rating']) for p in players_data])
    avg_age = np.mean([p.get('age', 25) for p in players_data])
    
    # Stats avanc√©es
    attack_power = calculate_attack_power(selected_players)
    defense_power = calculate_defense_power(selected_players)
    chemistry = calculate_team_chemistry(selected_players)
    
    # Bonus de formation
    formation_bonus = FORMATIONS[formation]["bonus"]
    attack_final = attack_power + formation_bonus["attack"]
    defense_final = defense_power + formation_bonus["defense"]
    creativity = avg_overall * 0.8 + formation_bonus["creativity"]
    
    return {
        "overall": avg_overall,
        "potential": avg_potential,
        "age": avg_age,
        "attack": max(0, min(100, attack_final)),
        "defense": max(0, min(100, defense_final)),
        "chemistry": chemistry,
        "creativity": max(0, min(100, creativity)),
        "experience": min(100, avg_age * 3)
    }

def calculate_attack_power(selected_players):
    """Calcule la puissance offensive"""
    attack_positions = ["ST", "LW", "RW", "CAM", "CF", "LF", "RF"]
    attack_players = [p for p in selected_players if p['position'] in attack_positions]
    
    if not attack_players:
        return 30
    
    attack_overall = np.mean([p['player']['overall_rating'] for p in attack_players])
    return min(100, attack_overall * 1.2)

def calculate_defense_power(selected_players):
    """Calcule la puissance d√©fensive"""
    defense_positions = ["GK", "CB", "LB", "RB", "CDM", "LWB", "RWB"]
    defense_players = [p for p in selected_players if p['position'] in defense_positions]
    
    if not defense_players:
        return 30
    
    defense_overall = np.mean([p['player']['overall_rating'] for p in defense_players])
    return min(100, defense_overall * 1.1)

def can_play_position(player_positions, required_position):
    """V√©rifie si un joueur peut jouer √† une position donn√©e"""
    if not player_positions or pd.isna(player_positions):
        return False
    
    player_pos_list = str(player_positions).split(',')
    compatible_positions = POSITION_COMPATIBILITY.get(required_position, [required_position])
    
    return any(pos.strip() in compatible_positions for pos in player_pos_list)

def get_players_for_position(df, position, exclude_ids=None, filters=None):
    """R√©cup√®re les joueurs avec filtres avanc√©s"""
    exclude_ids = exclude_ids or []
    
    # Filtre de position
    mask = df['positions'].apply(lambda x: can_play_position(x, position))
    available_players = df[mask & ~df['player_id'].isin(exclude_ids)].copy()
    
    # Application des filtres
    if filters:
        if 'age_range' in filters:
            min_age, max_age = filters['age_range']
            available_players = available_players[
                (available_players['age'] >= min_age) & 
                (available_players['age'] <= max_age)
            ]
        
        if 'leagues' in filters and filters['leagues']:
            available_players = available_players[
                available_players['league_name'].isin(filters['leagues'])
            ]
        
        if 'nationalities' in filters and filters['nationalities']:
            available_players = available_players[
                available_players['nationality'].isin(filters['nationalities'])
            ]
    
    return available_players

def optimize_team_advanced(df, formation, budget, game_mode, optimization_weights, filters):
    """Optimisation avanc√©e avec algorithme multicrit√®re"""
    selected_players = []
    remaining_budget = budget
    used_player_ids = set()
    
    formation_data = FORMATIONS[formation]
    formation_requirements = formation_data["positions"].copy()
    mode_data = GAME_MODES[game_mode]
    
    # Calcul du score composite pour chaque joueur
    def calculate_composite_score(player):
        weights = optimization_weights
        score = 0
        
        # Overall rating
        score += player['overall_rating'] * weights['overall'] / 100
        
        # Potentiel
        if 'potential' in player:
            score += player['potential'] * weights['potential'] / 100
        
        # √Çge (invers√© - plus jeune = mieux)
        age_score = max(0, 40 - player.get('age', 25)) / 40 * 100
        score += age_score * weights['age'] / 100
        
        # Efficacit√© prix
        if player['value_numeric'] > 0:
            efficiency = player['overall_rating'] / np.log1p(player['value_numeric'])
            score += efficiency * weights.get('efficiency', 10) / 100
        
        return score
    
    # Tri des positions par priorit√©
    position_priority = ["GK", "CB", "CDM", "LB", "RB", "LWB", "RWB", "CM", "LM", "RM", "CAM", "LW", "RW", "ST"]
    
    for position in position_priority:
        if position not in formation_requirements:
            continue
            
        needed_count = formation_requirements[position]
        
        for _ in range(needed_count):
            available_players = get_players_for_position(df, position, used_player_ids, filters)
            
            if available_players.empty:
                continue
            
            # Filtrer par budget (incluant salaires si mode mercato)
            if mode_data["constraints"].get("include_wages", False):
                # Budget sur 3 ans incluant salaires
                total_cost = available_players['value_numeric'] + (available_players['wage_numeric'] * 3)
                affordable_players = available_players[total_cost <= remaining_budget]
            else:
                affordable_players = available_players[available_players['value_numeric'] <= remaining_budget]
            
            if affordable_players.empty:
                continue
            
            # Appliquer les contraintes du mode de jeu
            if mode_data["constraints"].get("min_overall"):
                affordable_players = affordable_players[
                    affordable_players['overall_rating'] >= mode_data["constraints"]["min_overall"]
                ]
            
            if mode_data["constraints"].get("max_age"):
                affordable_players = affordable_players[
                    affordable_players['age'] <= mode_data["constraints"]["max_age"]
                ]
            
            if affordable_players.empty:
                continue
            
            # Calcul des scores et s√©lection du meilleur
            affordable_players['composite_score'] = affordable_players.apply(calculate_composite_score, axis=1)
            best_player = affordable_players.loc[affordable_players['composite_score'].idxmax()]
            
            # Calcul du co√ªt r√©el
            if mode_data["constraints"].get("include_wages", False):
                real_cost = best_player['value_numeric'] + (best_player['wage_numeric'] * 3)
            else:
                real_cost = best_player['value_numeric']
            
            selected_players.append({
                'player': best_player,
                'position': position,
                'cost': real_cost,
                'score': best_player['composite_score']
            })
            
            remaining_budget -= real_cost
            used_player_ids.add(best_player['player_id'])
    
    return selected_players, remaining_budget

def analyze_team_balance(selected_players):
    """Analyse l'√©quilibre de l'√©quipe"""
    if not selected_players:
        return []
    
    suggestions = []
    ages = [p['player'].get('age', 25) for p in selected_players]
    overalls = [p['player']['overall_rating'] for p in selected_players]
    
    # Analyse de l'√¢ge
    avg_age = np.mean(ages)
    if avg_age > 30:
        suggestions.append("üßì √âquipe vieillissante - Pensez √† rajeunir l'effectif")
    elif avg_age < 22:
        suggestions.append("üë∂ √âquipe tr√®s jeune - Manque d'exp√©rience possible")
    
    # Analyse de la r√©gularit√©
    overall_std = np.std(overalls)
    if overall_std > 8:
        suggestions.append("‚öñÔ∏è Gros √©carts de niveau - √âquipe d√©s√©quilibr√©e")
    
    # Analyse de l'attaque
    attack_power = calculate_attack_power(selected_players)
    if attack_power < 60:
        suggestions.append("‚öΩ Attaque faible - Manque de cr√©ativit√© offensive")
    
    # Analyse de la d√©fense
    defense_power = calculate_defense_power(selected_players)
    if defense_power < 60:
        suggestions.append("üõ°Ô∏è D√©fense fragile - Renforcez l'arri√®re-garde")
    
    # Analyse des nationalit√©s
    nationalities = [p['player'].get('nationality', 'Unknown') for p in selected_players]
    nationality_counts = pd.Series(nationalities).value_counts()
    if len(nationality_counts) < 4:
        suggestions.append("üåç Manque de diversit√© - Ajoutez des nationalit√©s")
    
    return suggestions

def display_advanced_formation(selected_players, formation):
    """Affichage avanc√© de la formation avec stats"""
    st.subheader(f"üèÜ Formation {formation}")
    
    # Lignes de formation personnalis√©es
    formation_layouts = {
        "4-3-3 (Attaque)": [["ST"], ["LW", "RW"], ["CM", "CDM", "CM"], ["LB", "CB", "CB", "RB"], ["GK"]],
        "4-4-2 (√âquilibr√©)": [["ST", "ST"], ["LM", "CM", "CM", "RM"], ["LB", "CB", "CB", "RB"], ["GK"]],
        "3-5-2 (Possession)": [["ST", "ST"], ["CM", "CDM", "CM"], ["LWB", "RWB"], ["CB", "CB", "CB"], ["GK"]],
        "4-2-3-1 (Cr√©atif)": [["ST"], ["CAM", "CAM", "CAM"], ["CDM", "CDM"], ["LB", "CB", "CB", "RB"], ["GK"]],
        "5-3-2 (D√©fense)": [["ST", "ST"], ["CM", "CM", "CM"], ["LWB", "RWB"], ["CB", "CB", "CB"], ["GK"]],
        "3-4-3 (Intense)": [["LW", "ST", "RW"], ["CM", "CM"], ["LM", "RM"], ["CB", "CB", "CB"], ["GK"]]
    }
    
    lines = formation_layouts.get(formation, [])
    player_dict = {p['position']: p for p in selected_players}
    
    for line_idx, line in enumerate(lines):
        cols = st.columns(len(line))
        for i, pos in enumerate(line):
            with cols[i]:
                if pos in player_dict:
                    player_info = player_dict[pos]
                    player = player_info['player']
                    
                    # Carte joueur avanc√©e
                    card_color = get_card_color(player['overall_rating'])
                    st.markdown(f"""
                    <div class="player-card" style="background: {card_color};">
                        <strong>{player['name'][:15]}</strong><br>
                        <small>{pos} | {player['overall_rating']} OVR</small><br>
                        <small>‚Ç¨{player_info['cost']:.1f}M | {player.get('age', 'N/A')} ans</small><br>
                        <small>{player.get('nationality', 'Unknown')[:3]}</small>
                    </div>
                    """, unsafe_allow_html=True)
                else:
                    st.markdown(f"""
                    <div style="text-align: center; padding: 10px; border: 2px dashed #ccc; border-radius: 10px; margin: 5px;">
                        <strong>-</strong><br><small>{pos}</small>
                    </div>
                    """, unsafe_allow_html=True)

def get_card_color(overall):
    """Couleur de carte selon l'overall"""
    if overall >= 90: return "linear-gradient(135deg, #FFD700, #FFA500)"  # Or
    elif overall >= 85: return "linear-gradient(135deg, #C0C0C0, #808080)"  # Argent
    elif overall >= 80: return "linear-gradient(135deg, #CD7F32, #8B4513)"  # Bronze
    elif overall >= 75: return "linear-gradient(135deg, #4CAF50, #45a049)"  # Vert
    else: return "linear-gradient(135deg, #666, #444)"  # Gris

def generate_export_data(selected_players, team_stats, formation):
    """G√©n√®re les donn√©es d'export"""
    export_data = {
        "formation": formation,
        "team_stats": team_stats,
        "players": [],
        "export_date": datetime.now().isoformat()
    }
    
    for p in selected_players:
        player_data = {
            "name": p['player']['name'],
            "position": p['position'],
            "overall": p['player']['overall_rating'],
            "potential": p['player'].get('potential', 0),
            "age": p['player'].get('age', 0),
            "nationality": p['player'].get('nationality', ''),
            "club": p['player'].get('club_name', ''),
            "value": p['cost']
        }
        export_data["players"].append(player_data)
    
    return export_data

def main():
    # Upload du fichier
    uploaded_file = st.file_uploader("üìÅ **Chargez votre base de donn√©es FC25**", type=['csv'])
    
    if uploaded_file is not None:
        df = load_data(uploaded_file)
        
        if df is not None:
            st.success(f"‚úÖ **{len(df):,} joueurs charg√©s avec succ√®s !**")
            
            # Interface principale avec tabs
            tab1, tab2, tab3, tab4 = st.tabs(["üéÆ **Constructeur**", "üìä **Analytics**", "‚öîÔ∏è **Comparaison**", "üì§ **Export**"])
            
            with tab1:
                col1, col2 = st.columns([1, 2])
                
                with col1:
                    st.markdown("### üéØ **Configuration**")
                    
                    # Mode de jeu
                    selected_mode = st.selectbox(
                        "üéÆ **Mode de jeu**", 
                        list(GAME_MODES.keys()),
                        help="Chaque mode a ses propres contraintes et objectifs"
                    )
                    
                    mode_info = GAME_MODES[selected_mode]
                    st.info(f"üìã {mode_info['description']}")
                    
                    # Budget
                    base_budget = st.number_input(
                        "üí∞ **Budget de base (millions ‚Ç¨)**", 
                        min_value=10, max_value=5000, value=500, step=25
                    )
                    
                    final_budget = base_budget * mode_info["budget_multiplier"]
                    st.metric("üí≥ Budget final", f"‚Ç¨{final_budget:.0f}M")
                    
                    # Formation
                    formation = st.selectbox("üìã **Formation tactique**", list(FORMATIONS.keys()))
                    
                    # Poids d'optimisation
                    st.markdown("### ‚öñÔ∏è **Crit√®res d'optimisation**")
                    
                    col_w1, col_w2 = st.columns(2)
                    with col_w1:
                        weight_overall = st.slider("‚≠ê Overall", 0, 100, 40, 5)
                        weight_potential = st.slider("üåü Potentiel", 0, 100, 30, 5)
                    with col_w2:
                        weight_age = st.slider("üë∂ Jeunesse", 0, 100, 20, 5)
                        weight_efficiency = st.slider("üí∞ Efficacit√©", 0, 100, 10, 5)
                    
                    optimization_weights = {
                        'overall': weight_overall,
                        'potential': weight_potential,
                        'age': weight_age,
                        'efficiency': weight_efficiency
                    }
                    
                    # Filtres avanc√©s
                    with st.expander("üîç **Filtres avanc√©s**"):
                        # √Çge
                        age_range = st.slider("üéÇ √Çge", 16, 40, (18, 35))
                        
                        # Ligues
                        if 'league_name' in df.columns:
                            leagues = st.multiselect(
                                "üèÜ Championnats",
                                options=sorted(df['league_name'].dropna().unique()),
                                default=[]
                            )
                        else:
                            leagues = []
                        
                        # Nationalit√©s
                        if 'nationality' in df.columns:
                            nationalities = st.multiselect(
                                "üåç Nationalit√©s",
                                options=sorted(df['nationality'].dropna().unique()),
                                default=[]
                            )
                        else:
                            nationalities = []
                    
                    filters = {
                        'age_range': age_range,
                        'leagues': leagues,
                        'nationalities': nationalities
                    }
                    
                    # Bouton d'optimisation
                    if st.button("üöÄ **OPTIMISER L'√âQUIPE**", type="primary", use_container_width=True):
                        with st.spinner("üîÑ Optimisation en cours..."):
                            selected_players, remaining_budget = optimize_team_advanced(
                                df, formation, final_budget, selected_mode, optimization_weights, filters
                            )
                            
                            if selected_players:
                                team_stats = calculate_team_stats(selected_players, formation)
                                suggestions = analyze_team_balance(selected_players)
                                
                                st.session_state.update({
                                    'team': selected_players,
                                    'remaining_budget': remaining_budget,
                                    'formation': formation,
                                    'total_budget': final_budget,
                                    'team_stats': team_stats,
                                    'suggestions': suggestions,
                                    'mode': selected_mode
                                })
                                st.success("‚úÖ **√âquipe optimis√©e avec succ√®s !**")
                            else:
                                st.error("‚ùå **Impossible de cr√©er une √©quipe avec ces contraintes**")
                
                with col2:
                    # Affichage des r√©sultats
                    if 'team' in st.session_state:
                        team = st.session_state['team']
                        team_stats = st.session_state['team_stats']
                        
                        # M√©triques avanc√©es
                        st.markdown("### üìä **Statistiques d'√©quipe**")
                        
                        col_m1, col_m2, col_m3, col_m4 = st.columns(4)
                        
                        with col_m1:
                            st.metric("üí∞ Co√ªt", f"‚Ç¨{sum(p['cost'] for p in team):.0f}M", 
                                    f"‚Ç¨{st.session_state['remaining_budget']:.0f}M restant")
                        with col_m2:
                            st.metric("‚≠ê Overall", f"{team_stats['overall']:.1f}", 
                                    f"{team_stats['potential']:.1f} pot.")
                        with col_m3:
                            st.metric("üß™ Chimie", f"{team_stats['chemistry']:.0f}%", 
                                    f"{team_stats['age']:.1f} ans moy.")
                        with col_m4:
                            st.metric("‚öîÔ∏è Attaque", f"{team_stats['attack']:.0f}", 
                                    f"{team_stats['defense']:.0f} d√©f.")
                        
                        # Graphique radar des stats
                        fig_radar = go.Figure()
                        
                        categories = ['Attaque', 'D√©fense', 'Cr√©ativit√©', 'Chimie', 'Exp√©rience']
                        values = [
                            team_stats['attack'],
                            team_stats['defense'], 
                            team_stats['creativity'],
                            team_stats['chemistry'],
                            team_stats['experience']
                        ]
                        
                        fig_radar.add_trace(go.Scatterpolar(
                            r=values,
                            theta=categories,
                            fill='toself',
                            name='Votre √©quipe',
                            line_color='rgb(255, 107, 53)'
                        ))
                        
                        fig_radar.update_layout(
                            polar=dict(
                                radialaxis=dict(visible=True, range=[0, 100])
                            ),
                            title="üìà Profil de l'√©quipe",
                            height=400
                        )
                        
                        st.plotly_chart(fig_radar, use_container_width=True)
                        
                        # Formation tactique
                        display_advanced_formation(team, st.session_state['formation'])
                        
                        # Suggestions d'am√©lioration
                        if st.session_state.get('suggestions'):
                            st.markdown("### üí° **Suggestions d'am√©lioration**")
                            for suggestion in st.session_state['suggestions']:
                                st.info(suggestion)
            
            with tab2:
                if 'team' in st.session_state:
                    team = st.session_state['team']
                    
                    st.markdown("### üìä **Analytics avanc√©es**")
                    
                    # Tableau d√©taill√©
                    team_data = []
                    for p in team:
                        player = p['player']
                        team_data.append({
                            'Position': p['position'],
                            'Nom': player['name'],
                            'Club': player.get('club_name', 'N/A'),
                            'Overall': player['overall_rating'],
                            'Potentiel': player.get('potential', 'N/A'),
                            '√Çge': player.get('age', 'N/A'),
                            'Nationalit√©': player.get('nationality', 'N/A'),
                            'Valeur ‚Ç¨M': f"{p['cost']:.1f}",
                            'Efficacit√©': f"{player.get('efficiency_score', 0):.2f}"
                        })
                    
                    team_df = pd.DataFrame(team_data)
                    st.dataframe(team_df, use_container_width=True, height=400)
                    
                    # Graphiques analytiques
                    col_g1, col_g2 = st.columns(2)
                    
                    with col_g1:
                        # Distribution des √¢ges
                        ages = [p['player'].get('age', 25) for p in team]
                        fig_age = px.histogram(
                            x=ages, 
                            nbins=10, 
                            title="üìä Distribution des √¢ges",
                            labels={'x': '√Çge', 'y': 'Nombre de joueurs'}
                        )
                        st.plotly_chart(fig_age, use_container_width=True)
                        
                        # R√©partition par nationalit√©
                        nationalities = [p['player'].get('nationality', 'Unknown') for p in team]
                        nat_counts = pd.Series(nationalities).value_counts()
                        
                        fig_nat = px.pie(
                            values=nat_counts.values, 
                            names=nat_counts.index,
                            title="üåç R√©partition des nationalit√©s"
                        )
                        st.plotly_chart(fig_nat, use_container_width=True)
                    
                    with col_g2:
                        # Overall par position
                        positions = [p['position'] for p in team]
                        overalls = [p['player']['overall_rating'] for p in team]
                        
                        fig_pos = px.bar(
                            x=positions, 
                            y=overalls,
                            title="‚≠ê Overall par position",
                            labels={'x': 'Position', 'y': 'Overall'}
                        )
                        st.plotly_chart(fig_pos, use_container_width=True)
                        
                        # Analyse pieds forts
                        foot_data = {'Droitier': 7, 'Gaucher': 2, 'Ambidextre': 2}  # Exemple
                        fig_foot = px.bar(
                            x=list(foot_data.keys()),
                            y=list(foot_data.values()),
                            title="ü¶∂ R√©partition des pieds forts",
                            color=list(foot_data.keys())
                        )
                        st.plotly_chart(fig_foot, use_container_width=True)
                    
                    # Analyse comparative
                    st.markdown("### üìà **Analyse comparative**")
                    
                    col_comp1, col_comp2, col_comp3 = st.columns(3)
                    
                    with col_comp1:
                        avg_overall_league = df['overall_rating'].mean()
                        diff_overall = team_df['Overall'].astype(float).mean() - avg_overall_league
                        st.metric(
                            "üìä Niveau vs moyenne", 
                            f"{team_df['Overall'].astype(float).mean():.1f}",
                            f"{diff_overall:+.1f} pts"
                        )
                    
                    with col_comp2:
                        avg_age_league = df['age'].mean()
                        team_avg_age = pd.to_numeric(team_df['√Çge'], errors='coerce').mean()
                        diff_age = team_avg_age - avg_age_league
                        st.metric(
                            "üë∂ √Çge vs moyenne",
                            f"{team_avg_age:.1f} ans",
                            f"{diff_age:+.1f} ans"
                        )
                    
                    with col_comp3:
                        total_value = sum(p['cost'] for p in team)
                        value_per_point = total_value / team_df['Overall'].astype(float).mean()
                        st.metric(
                            "üí∞ Co√ªt par point",
                            f"‚Ç¨{value_per_point:.1f}M",
                            "Efficacit√©"
                        )
                else:
                    st.info("üéÆ Cr√©ez d'abord une √©quipe dans l'onglet Constructeur !")
            
            with tab3:
                st.markdown("### ‚öîÔ∏è **Comparaison d'√©quipes**")
                
                # Sauvegarde d'√©quipes
                if 'team' in st.session_state:
                    team_name = st.text_input("üíæ Nom de l'√©quipe √† sauvegarder")
                    if st.button("üíæ Sauvegarder cette √©quipe"):
                        if team_name:
                            if 'saved_teams' not in st.session_state:
                                st.session_state['saved_teams'] = {}
                            
                            st.session_state['saved_teams'][team_name] = {
                                'team': st.session_state['team'],
                                'stats': st.session_state['team_stats'],
                                'formation': st.session_state['formation'],
                                'mode': st.session_state['mode']
                            }
                            st.success(f"‚úÖ √âquipe '{team_name}' sauvegard√©e !")
                        else:
                            st.warning("‚ö†Ô∏è Veuillez entrer un nom pour l'√©quipe")
                
                # Affichage des √©quipes sauvegard√©es
                if st.session_state.get('saved_teams'):
                    st.markdown("#### üìö **√âquipes sauvegard√©es**")
                    
                    teams_to_compare = st.multiselect(
                        "S√©lectionnez les √©quipes √† comparer",
                        options=list(st.session_state['saved_teams'].keys()),
                        default=list(st.session_state['saved_teams'].keys())[:2]
                    )
                    
                    if len(teams_to_compare) >= 2:
                        # Tableau de comparaison
                        comparison_data = []
                        
                        for team_name in teams_to_compare:
                            team_data = st.session_state['saved_teams'][team_name]
                            stats = team_data['stats']
                            
                            comparison_data.append({
                                '√âquipe': team_name,
                                'Formation': team_data['formation'],
                                'Mode': team_data['mode'],
                                'Overall': f"{stats['overall']:.1f}",
                                'Potentiel': f"{stats['potential']:.1f}",
                                '√Çge moyen': f"{stats['age']:.1f}",
                                'Attaque': f"{stats['attack']:.0f}",
                                'D√©fense': f"{stats['defense']:.0f}",
                                'Chimie': f"{stats['chemistry']:.0f}%",
                                'Co√ªt total': f"‚Ç¨{sum(p['cost'] for p in team_data['team']):.0f}M"
                            })
                        
                        comparison_df = pd.DataFrame(comparison_data)
                        st.dataframe(comparison_df, use_container_width=True)
                        
                        # Graphique comparatif radar
                        fig_comp = go.Figure()
                        
                        categories = ['Overall', 'Attaque', 'D√©fense', 'Chimie', 'Cr√©ativit√©']
                        
                        colors = ['rgb(255, 107, 53)', 'rgb(53, 107, 255)', 'rgb(107, 255, 53)', 'rgb(255, 53, 107)']
                        
                        for i, team_name in enumerate(teams_to_compare[:4]):  # Max 4 √©quipes
                            team_data = st.session_state['saved_teams'][team_name]
                            stats = team_data['stats']
                            
                            values = [
                                stats['overall'],
                                stats['attack'],
                                stats['defense'],
                                stats['chemistry'],
                                stats['creativity']
                            ]
                            
                            fig_comp.add_trace(go.Scatterpolar(
                                r=values,
                                theta=categories,
                                fill='toself',
                                name=team_name,
                                line_color=colors[i % len(colors)]
                            ))
                        
                        fig_comp.update_layout(
                            polar=dict(radialaxis=dict(visible=True, range=[0, 100])),
                            title="üìä Comparaison des √©quipes",
                            height=500
                        )
                        
                        st.plotly_chart(fig_comp, use_container_width=True)
                        
                        # Recommandation
                        if len(teams_to_compare) == 2:
                            team1_stats = st.session_state['saved_teams'][teams_to_compare[0]]['stats']
                            team2_stats = st.session_state['saved_teams'][teams_to_compare[1]]['stats']
                            
                            winner_categories = []
                            for category in ['overall', 'attack', 'defense', 'chemistry']:
                                if team1_stats[category] > team2_stats[category]:
                                    winner_categories.append(f"‚úÖ {teams_to_compare[0]} domine en {category}")
                                elif team2_stats[category] > team1_stats[category]:
                                    winner_categories.append(f"‚úÖ {teams_to_compare[1]} domine en {category}")
                            
                            st.markdown("#### üèÜ **Analyse comparative**")
                            for category in winner_categories:
                                st.write(category)
                else:
                    st.info("üíæ Sauvegardez d'abord des √©quipes pour les comparer !")
            
            with tab4:
                st.markdown("### üì§ **Export et partage**")
                
                if 'team' in st.session_state:
                    team = st.session_state['team']
                    team_stats = st.session_state['team_stats']
                    formation = st.session_state['formation']
                    
                    # Export CSV
                    export_data = generate_export_data(team, team_stats, formation)
                    
                    col_exp1, col_exp2 = st.columns(2)
                    
                    with col_exp1:
                        st.markdown("#### üìä **Export CSV**")
                        
                        csv_data = []
                        for p in team:
                            player = p['player']
                            csv_data.append({
                                'Nom': player['name'],
                                'Position': p['position'],
                                'Overall': player['overall_rating'],
                                'Potentiel': player.get('potential', ''),
                                'Age': player.get('age', ''),
                                'Nationalit√©': player.get('nationality', ''),
                                'Club': player.get('club_name', ''),
                                'Valeur_Millions': p['cost'],
                                'Formation': formation
                            })
                        
                        csv_df = pd.DataFrame(csv_data)
                        csv_string = csv_df.to_csv(index=False)
                        
                        st.download_button(
                            label="üì• T√©l√©charger CSV",
                            data=csv_string,
                            file_name=f"equipe_fc25_{datetime.now().strftime('%Y%m%d_%H%M')}.csv",
                            mime="text/csv"
                        )
                    
                    with col_exp2:
                        st.markdown("#### üìã **Export JSON**")
                        
                        json_string = json.dumps(export_data, indent=2, ensure_ascii=False)
                        
                        st.download_button(
                            label="üì• T√©l√©charger JSON",
                            data=json_string,
                            file_name=f"equipe_fc25_{datetime.now().strftime('%Y%m%d_%H%M')}.json",
                            mime="application/json"
                        )
                    
                    # R√©sum√© pour partage
                    st.markdown("#### üîó **R√©sum√© pour partage**")
                    
                    share_text = f"""
üèÜ **MON √âQUIPE FC25 ULTIMATE**

üìã **Formation:** {formation}
üéÆ **Mode:** {st.session_state.get('mode', 'Standard')}
üí∞ **Budget utilis√©:** ‚Ç¨{sum(p['cost'] for p in team):.0f}M

üìä **Statistiques:**
‚≠ê Overall moyen: {team_stats['overall']:.1f}
‚öîÔ∏è Attaque: {team_stats['attack']:.0f}/100
üõ°Ô∏è D√©fense: {team_stats['defense']:.0f}/100
üß™ Chimie: {team_stats['chemistry']:.0f}%

üë• **Titulaires:**
"""
                    
                    for p in team:
                        share_text += f"‚Ä¢ {p['position']}: {p['player']['name']} ({p['player']['overall_rating']} OVR)\n"
                    
                    share_text += f"\nüîß **Cr√©√© avec FC25 Ultimate Team Builder Pro**"
                    
                    st.text_area(
                        "Copier pour partager sur les r√©seaux sociaux:",
                        share_text,
                        height=300
                    )
                    
                    # Statistiques d√©taill√©es
                    st.markdown("#### üìà **Rapport d√©taill√©**")
                    
                    with st.expander("üìä Voir le rapport complet"):
                        st.markdown(f"""
**RAPPORT D'ANALYSE D'√âQUIPE**

**Configuration:**
- Formation: {formation}
- Mode de jeu: {st.session_state.get('mode', 'Standard')}  
- Budget total: ‚Ç¨{st.session_state.get('total_budget', 0):.0f}M
- Budget utilis√©: ‚Ç¨{sum(p['cost'] for p in team):.0f}M
- Budget restant: ‚Ç¨{st.session_state.get('remaining_budget', 0):.0f}M

**Statistiques d'√©quipe:**
- Overall moyen: {team_stats['overall']:.2f}
- Potentiel moyen: {team_stats['potential']:.2f}
- √Çge moyen: {team_stats['age']:.1f} ans
- Puissance offensive: {team_stats['attack']:.0f}/100
- Solidit√© d√©fensive: {team_stats['defense']:.0f}/100
- Chimie d'√©quipe: {team_stats['chemistry']:.0f}%
- Cr√©ativit√©: {team_stats['creativity']:.0f}/100
- Exp√©rience: {team_stats['experience']:.0f}/100

**R√©partition budg√©taire:**
- Co√ªt moyen par joueur: ‚Ç¨{sum(p['cost'] for p in team)/len(team):.1f}M
- Joueur le plus cher: ‚Ç¨{max(p['cost'] for p in team):.1f}M
- Efficacit√© (Overall/‚Ç¨): {team_stats['overall']/(sum(p['cost'] for p in team)/len(team)):.2f}

**Analyse:**
{chr(10).join(st.session_state.get('suggestions', ['√âquipe bien √©quilibr√©e !']))}
                        """)
                else:
                    st.info("üéÆ Cr√©ez d'abord une √©quipe pour l'exporter !")
            
            # Aper√ßu des donn√©es
            with st.expander("üëÄ **Base de donn√©es - Aper√ßu**"):
                st.markdown(f"**üìä {len(df):,} joueurs dans la base**")
                
                col_info1, col_info2, col_info3 = st.columns(3)
                with col_info1:
                    st.metric("‚≠ê Overall max", int(df['overall_rating'].max()))
                with col_info2: 
                    st.metric("üåç Nationalit√©s", len(df['nationality'].unique()))
                with col_info3:
                    st.metric("üèÜ Ligues", len(df.get('league_name', pd.Series()).unique()))
                
                st.dataframe(df.head(10), use_container_width=True)
                
                if st.checkbox("üîç Afficher toutes les colonnes"):
                    st.write("**Colonnes disponibles:**", list(df.columns))

if __name__ == "__main__":
    main() 
